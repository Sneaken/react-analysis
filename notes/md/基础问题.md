## setState 对象的时候为什么需要解构?

因为不解构的话, 会触发优化路径, 具体代码在 dispatchSetState 中

## key 的作用是什么？

key是节点的唯一标识, 用于在变化前后关联节点

## 为什么不推荐 index 作为 key?

如果只是用作数据展示的时候其实是没有问题的, 但是在需要操作数据的场景下就很容易出现问题。
当 index 作为 key 时, 如果反转列表（或者其他操作）, 此时对子组件（item）来说因为 key 没变,
所以子组件是复用的, 只需要根据 props 更新子组件即可, 而子组件内部的state是复用的, 所以可能会产生错误。

比较好的答案：
这是因为当元素顺序发生变化时, 它们的索引也会改变, 这会导致 React 重新渲染整个列表。
这样不仅会影响性能, 而且还可能导致组件状态混乱。
相比之下, 使用唯一的、不可变的 key 来标识列表中的每个元素会更好。
这样, 当元素顺序发生变化时, React 就可以跟踪哪些元素被移动、添加或删除, 并仅对实际发生变化的元素进行重新渲染。
总之, 使用有意义且唯一的 key 来优化列表渲染是一种很好的做法, 它可以提高性能并避免组件状态混乱的问题。

## 能否修改 props / state ?

dev 环境中 props 是会被 Object.freeze 的, 所以是不能被修改的

但是 state 是可以被修改的, 因为没有这个限制, 但是由于 setState 使用 Object.is 来判断是否发生变更的, 所以不会触发渲染。

## fiber.pendingProps 是什么时候转换成 memoizedProps ?

每次 beginWork 之后, 切换 workInProgress 之前。

## setState 同步还是异步？（半）自动批处理? v16 和 v18 有什么区别?

v18 将自动批量更新交由 schedule 阶段的调度策略完成, 实现了自动化, 从代码来看基本上 BatchedContext 已经没有消费了
v16 在 executionContext 中包含 BatchedContext 的情况下, 才会执行自动批量更新

## stateNode 是什么时候生成的?

- HostComponent: completeWork createInstance 以后, 完成 appendAllChildren 之后就被立马赋值了
- IndeterminateComponent 中长的像类组件的函数组件: mountIndeterminateComponent 中被假定为 ClassComponent 后在
  adoptClassInstance 中挂载的
- ClassComponent: beginWork updateClassComponent 发现没有 stateNode 后, 执行 constructClassInstance 中在
  adoptClassInstance 挂载的

## 当传入组件的 props 里面的各项值都未发生变化的时候, 组件会重新渲染么?

在没有 memo 包裹的情况是会触发渲染, 因为每次渲染 props 都是一个新的对象, 可以在 createElement 查看创建 JSX 的过程

## 什么时候组件会重新渲染? 有哪些优化路径?

## 为什么要在 jsx 文件开头写 "import React from 'react'", 新的 JSX 转换器有什么作用?

在旧的版本中单反涉及到 jsx对象, 就会被 babel 自动转译成 React.createElement, 如果文件没有引入 "import React from '
react'", 就会报找不到 React 的 错误。

而使用了新的 JSX 转换器后, 就可以从组件代码中删除只是为了转换 JSX 而存在的 React 导入。

这样做有什么好处？

1. 减少捆绑文件的大小
2. 减少动态属性查询

## 为什么 string 类型的 ref 会被废弃?

1. string 类型的 ref 存在命名冲突的问题。当多个组件使用相同的字符串 ref 名称时, 可能会产生命名冲突, 这会导致 ref
   引用错误的组件实例, 从而导致意外行为和错误。
2. string 类型的 ref, 无法直接获取 this 的指向, 所以, React 需要持续跟踪当前 render 组件, 这会让 React 在性能上变慢。
3. 使用 "render callback" 模式, 它无法像大多数人预期的那样工作。

    ```jsx
    class MyComponent extends Component {
      renderRow = (index) => {
        // This won't work. Ref will get attached to DataTable rather than MyComponent:
        return <input ref={'input-' + index} />;
    
        // This would work though! Callback refs are awesome.
        return <input ref={input => this['input-' + index] = input} />;
      }
     
      render() {
        return <DataTable data={this.props.data} renderRow={this.renderRow} />
      }
    }
    ```

## 简述一下 diff 算法

1. 单节点 diff

   遍历 currentFirstChild:
   如果 key 不同, 标记删除当前节点（不能复用）, 继续遍历。
   如果 key 相同, type 不同, 标记删除当前节点以及后续兄弟节点, 跳出遍历, 创建新的 fiber 节点。
   如果 key 相同, type 相同, 标记删除后续兄弟节点, 复用 fiber, diff 结束。

   如果还是没有能复用的 fiber 节点, 就创建新的 fiber 节点。

2. 多节点 diff

   第一轮遍历尝试逐个复用节点
   如果 key 相同, type 相同, 就 update, 然后链接到结果链表后
   如果 key 相同, type 不同, 就 create, 删除 oldFiber, 然后链接到结果链表后
   如果 key 不同, 不能复用就跳出第一轮遍历

   如果 newChildren 遍历完, 标记删除剩余的 oldFiber 节点, diff 结束
   如果 newChildren 没遍历完, oldFiber 遍历完了, 就依次创建新的节点, 并且链接到上一个节点。 diff 结束。

   第二轮遍历以 newChildren 为主, 尝试从 map 中找到能复用的 fiber 对象,
   最后标记删除 map 中剩余的 oldFiber 节点, 因为这些都用不上了

## 什么是 HOC(高阶组件)

接受一个组件作为参数, 返回一个新的组件

```jsx
// 定义一个接受组件作为参数的高阶组件
function withHigherOrderComponent (WrappedComponent) {
  return class extends React.Component {
    constructor (props) {
      super(props);
      // 这里可以初始化一些状态或其他操作
    }

    render () {
      // 渲染被包装组件, 并向其传递 props
      return <WrappedComponent {...this.props} />;
    }
  }
}

// 定义被包装的组件
class MyComponent extends React.Component {
  render () {
    return <div>Hello, {this.props.name}!</div>;
  }
}

// 使用高阶组件包装 MyComponent 组件
const MyHigherOrderComponent = withHigherOrderComponent(MyComponent);
```

## setState 同步异步?

大前提: 同步异步都是针对 ClassComponent

v17 以后都是异步的，不存在同步的说法。

v16 中 setTimout, promise.then 等回调中 setState 是同步的, 其他情况都是异步的。

为什么是同步的? 因为在这些情况下上下文中不存在 BatchedContext, 所以无法批量执行，每执行一次都会使组件重新 render 一下。

## fiber 的 mode 是怎么来的?

从 createFiberFromElement 调用的地方可以看出是继承的父级的 mode, 
所以需要追溯到 rootFiber.mode 的确定（createHostRootFiber 里面确定的 mode）。
以及被调试组件包裹的情况下会被附加 mode
