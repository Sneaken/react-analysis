## setState 对象的时候为什么需要解构?

因为不解构的话, 会触发优化路径, 具体代码在 dispatchSetState 中

## key 的作用是什么？

key是节点的唯一标识, 用于在变化前后关联节点

## 能否修改 props / state ?

dev 环境中 props 是会被 Object.freeze 的, 所以是不能被修改的

但是 state 是可以被修改的, 因为没有这个限制, 但是由于 setState 使用 Object.is 来判断是否发生变更的, 所以不会触发渲染。

## fiber.pendingProps 是什么时候转换成 memoizedProps ?

每次 beginWork 之后, 切换 workInProgress 之前。

## setState 同步还是异步？（半）自动批处理? v16 和 v18 有什么区别?

v18 将自动批量更新交由 schedule 阶段的调度策略完成, 实现了自动化
v16 在 executionContext 中包含 BatchedContext 的情况下, 才会执行自动批量更新

## stateNode 是什么时候生成的?

- HostComponent: completeWork createInstance 以后, 完成 appendAllChildren 之后就被立马赋值了
- IndeterminateComponent 中长的像类组件的函数组件: mountIndeterminateComponent 中被假定为 ClassComponent 后在
  adoptClassInstance 中挂载的
- ClassComponent: beginWork updateClassComponent 发现没有 stateNode 后, 执行 constructClassInstance 中在
  adoptClassInstance 挂载的

## 当传入组件的 props 里面的各项值都未发生变化的时候, 组件会重新渲染么?

在没有 memo 包裹的情况是会触发渲染, 因为每次渲染 props 都是一个新的对象, 可以在 createElement 查看创建 JSX 的过程

## 什么时候组件会重新渲染? 有哪些优化路径?

## 为什么要在 jsx 文件开头写 "import React from 'react'", 新的 JSX 转换器有什么作用?

在旧的版本中单反涉及到 jsx对象, 就会被 babel 自动转译成 React.createElement, 如果文件没有引入 "import React from '
react'", 就会报找不到 React 的 错误。

而使用了新的 JSX 转换器后, 就可以从组件代码中删除只是为了转换 JSX 而存在的 React 导入。

这样做有什么好处？

1. 减少捆绑文件的大小
2. 减少动态属性查询

## 为什么 string 类型的 ref 会被废弃?

1. string 类型的 ref 存在命名冲突的问题。当多个组件使用相同的字符串 ref 名称时, 可能会产生命名冲突, 这会导致 ref
   引用错误的组件实例, 从而导致意外行为和错误。
2. string 类型的 ref, 无法直接获取 this 的指向, 所以, React 需要持续跟踪当前 render 组件, 这会让 React 在性能上变慢。
3. 使用 "render callback" 模式, 它无法像大多数人预期的那样工作。

    ```jsx
    class MyComponent extends Component {
      renderRow = (index) => {
        // This won't work. Ref will get attached to DataTable rather than MyComponent:
        return <input ref={'input-' + index} />;
    
        // This would work though! Callback refs are awesome.
        return <input ref={input => this['input-' + index] = input} />;
      }
     
      render() {
        return <DataTable data={this.props.data} renderRow={this.renderRow} />
      }
    }
    ```

## 简述一下 diff 算法

1. 单节点 diff

   遍历 currentFirstChild:
   如果 key 不同, 标记删除当前节点（不能复用）, 继续遍历, 如果 key 相同, type 不同, 标记删除当前节点以及后续兄弟节点,
   继续遍历兄弟节点。
   如果 key 相同, type 相同, 标记删除后续兄弟节点, 复用 fiber, diff 结束。

   如果还是没有能复用的 fiber 节点, 就创建新的 fiber 节点。

2. 多节点 diff

   第一轮遍历尝试逐个复用节点
   如果 key 相同, type 相同, 就 update, 然后链接到结果链表后
   如果 key 相同, type 不同, 就 create, 删除 oldFiber, 然后链接到结果链表后
   如果 key 不同, 不能复用就跳出第一轮遍历

   如果 newChildren 遍历完, 标记删除剩余的 oldFiber 节点, diff 结束
   如果 newChildren 没遍历完, oldFiber 遍历完了, 就依次创建新的节点, 并且链接到上一个节点。 diff 结束。

   第二轮遍历以 newChildren 为主, 尝试从 map 中找到能复用的 fiber 对象,
   最后标记删除 map 中剩余的 old fiber 节点, 因为这些都用不上了
