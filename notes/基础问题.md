## setState 对象的时候为什么需要解构?

因为不解构的话，会触发优化路径，具体代码在 dispatchSetState 中

## key 的作用是什么？

key是节点的唯一标识，用于在变化前后关联节点

## 能否修改 props / state ?

dev 环境中 props 是会被 Object.freeze 的, 所以是不能被修改的

但是 state 是可以被修改的，因为没有这个限制，但是由于 setState 使用 Object.is 来判断是否发生变更的，所以不会触发渲染。

## fiber.pendingProps 是什么时候转换成 memoizedProps ?

每次 beginWork 之后, 切换 workInProgress 之前。

## setState 同步还是异步？（半）自动批处理? v16 和 v18 有什么区别?

v18 将自动批量更新交由 schedule 阶段的调度策略完成，实现了自动化
v16 在 executionContext 中包含 BatchedContext 的情况下，才会执行自动批量更新

## stateNode 是什么时候生成的?

- HostComponent: completeWork createInstance 以后， 完成 appendAllChildren 之后就被立马赋值了
- IndeterminateComponent 中长的像类组件的函数组件: mountIndeterminateComponent 中被假定为 ClassComponent 后在
  adoptClassInstance 中挂载的
- ClassComponent: beginWork updateClassComponent 发现没有 stateNode 后，执行 constructClassInstance 中在
  adoptClassInstance 挂载的

## 当传入组件的 props 里面的各项值都未发生变化的时候, 组件会重新渲染么?

在没有 memo 包裹的情况是会触发渲染，因为每次渲染 props 都是一个新的对象, 可以在 createElement 查看创建 JSX 的过程

## 什么时候组件会重新渲染? 有哪些优化路径?

## 什么是合成事件，为什么要设计合成事件?

在 React 中，事件对象并不是原生的 DOM 事件对象，而是一种由 React 自己合成的事件对象，称为合成事件。

React 设计合成事件的主要原因是为了解决跨浏览器兼容性问题。
在不同的浏览器中，原生的事件对象可能存在差异，React 使用合成事件来隐藏这些差异，使得开发者在编写代码时不需要关注浏览器之间的差异，提高了开发效率。

此外，React 的合成事件还有以下优点：

1. 对象复用：合成事件对象可以被复用，减少对象创建的开销，提高性能。
2. 事件委托：React 的事件委托机制可以有效地减少事件绑定的数量，提高应用的性能。
3. 提高可维护性：React 的合成事件可以被统一管理，方便应用的维护和调试。

## 什么是事件池，为什么 v17 要删除它?

在 React 之前的版本中，React 事件系统使用了一个事件池的概念，即为了优化事件处理的性能，将所有事件对象合并成一个共享的事件池，每次事件处理完毕后将事件对象重置并放回事件池中以供下次使用。

然而，这种优化并非完美的，可能会导致一些潜在的问题，例如：

- 如果某个事件处理函数异步执行，事件对象在异步函数执行期间仍被占用，其他的事件处理函数无法使用该事件对象，可能会导致一些奇怪的问题。
- 在 React 中，由于更新过程是异步的，如果多个事件处理函数同时更新了状态，可能会导致每个函数处理的事件对象都不同，可能会导致状态更新出现问题。

为了解决这些问题，React 17 中已经移除了事件池的概念。
现在每个事件处理函数都会接收到独立的事件对象，事件对象只在事件处理函数执行期间有效，并在处理完毕后立即被销毁。
这样可以确保每个事件处理函数都能使用正确的事件对象，并避免了一些潜在的问题。

## 合成事件在 v16 和 v17+ 的区别?

在 React v16 中，合成事件是使用单一的事件处理器来处理所有事件类型的，它会在捕获或冒泡阶段收集事件并通过统一的代码路径处理这些事件。由于事件处理器只有一个，因此在处理大量事件时可能会影响性能。

在 React v17 中，合成事件进行了一些调整。与 v16 不同，它现在仅在实际需要时才收集并处理事件，而不是在每次事件处理程序被调用时都收集和处理事件。这种变化减轻了性能负担，特别是在处理大量事件时。
另外，在 v17 中，合成事件还通过分离事件处理逻辑来优化事件处理的性能，例如对于常见的事件处理程序（如onClick）进行特殊处理，以避免不必要的事件收集和处理。

## 为什么针对同一个事件, 即使可能存在多次回调, 也只需要注册一次监听

在 React 中，事件处理程序是注册在 document(v16)/root container(v17+) 上的。当事件触发时，事件将从触发的元素（事件源）开始沿着 DOM 树向上冒泡，直到达到 document。因此，即使在同一元素上存在多个事件处理函数，当事件触发时，它们都会被调用。

React 通过事件委托的方式来提高性能，即在 root container 上注册事件监听器，然后在内部记录事件源以及响应事件的处理程序，并在适当的时间调用它们。这样，每次事件触发只需要遍历一次 DOM 树即可找到相应的处理程序，而不需要为每个具体的事件源分别注册事件监听器，从而节省了内存开销和注册事件监听器的时间成本。

